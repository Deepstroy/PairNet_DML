# -*- coding: utf-8 -*-
"""Motivation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vWHMLGFbni-hVwoXuuj1A4vSZ2BRXAMI
"""

import numpy as np
import matplotlib as mpl
mpl.rcParams.update(mpl.rcParamsDefault)
import random

import matplotlib.pyplot as plt
import pandas as pd
import ot
# plt.rcParams['text.usetex'] = True

np.random.seed(2)
random.seed(2)

"""# Covariance Matrix"""

def rbf_kernel(x1, x2, width=1.0):
    sq_dist = np.sum((x1 - x2) ** 2)
    return np.exp(-width * sq_dist)

def sample_gaussian_process(x_values, width, x_test=None):
    num_points = len(x_values)

    # Compute the covariance matrix (Gram matrix) using the RBF kernel for training points
    K = np.zeros((num_points, num_points))
    for i in range(num_points):
        for j in range(num_points):
            K[i, j] = rbf_kernel(x_values[i], x_values[j], width)

    # Generate a sample from the prior Gaussian process
    mean_prior = np.zeros(num_points)
    sample_prior = np.random.multivariate_normal(mean_prior, K)
    if x_test is None:
        return sample_prior

    # Compute the covariance matrix between training and test points
    K_star = np.zeros((num_points, len(x_test)))
    for i in range(num_points):
        for j in range(len(x_test)):
            K_star[i, j] = rbf_kernel(x_values[i], x_test[j], width)

    # Compute the covariance matrix for test points
    K_test = np.zeros((len(x_test), len(x_test)))
    for i in range(len(x_test)):
        for j in range(len(x_test)):
            K_test[i, j] = rbf_kernel(x_test[i], x_test[j], width)

    # Calculate the mean and covariance of the predictive distribution
    mean_test = np.dot(K_star.T, np.linalg.solve(K, sample_prior))
    return mean_test

"""These are the GT parameters"""
mu_0 = 1
mu_tau = 0.2

"""Generate training $x$. Assume $X_\text{tst}$ = $X_0 \cup X_1$"""

n0 = 5
n1= 5
n = n0+n1

x_0 = np.random.normal(-0.3, 0.5, n0)
x_1 = np.random.normal(0.3, 0.5, n1)
x_test = np.concatenate([x_0, x_1])

f0_tst = sample_gaussian_process(x_values=x_test, width=mu_0)
f0_star = f0_tst[:n0]
ftau_tst = sample_gaussian_process(x_values=x_test, width=mu_tau)
f1_tst = f0_tst + ftau_tst
f1_star = f1_tst[n0:]
print(x_0)
print(x_1)
print(ftau_tst)

argsort = np.argsort(x_test)
corr_plot = True

def std_norm(df, column):
    c = df[column]
    df[f"{column}-std"] = (c - c.mean())/c.std()

"""# Sinkhorn"""

def OT_distances(x_0, x_1):
    if x_0.ndim == 1:
        x_0 = x_0.reshape(-1, 1)
    if x_1.ndim == 1:
        x_1 = x_1.reshape(-1, 1)

    M = ot.dist(x_0, x_1)
    print("cost: ", M.shape)
    print(M)

    # Assume uniform distribution
    a = np.ones(len(x_0)) / len(x_0)
    b = np.ones(len(x_1)) / len(x_1)

    lambd = 1e-1
    Gs = ot.sinkhorn(a, b, M, lambd)
    print("Transport matrix: ", Gs.shape)
    print(Gs)
    return Gs


results_dict = {
    "mu_0": [],
    "mu_tau": [],
    "floss": [],
    "diffloss": [],
    "true_loss": [],
}

dists = np.abs(x_0.reshape(-1, 1) - x_1.reshape(1, -1))
assert dists.shape == (n0, n1)

nbrs_0 = np.argmin(dists, axis=1)
assert len(nbrs_0) == n0
nbrs_1 = np.argmin(dists, axis=0)
assert len(nbrs_1) == n1
print(dists)
print(nbrs_0)
print(nbrs_1)

sinkhorn = OT_distances(x_0, x_1)

mindiffloss = 100
minfloss = 100
for method in ["nbrs"]: #, "ot"]:
    print("****"*10, method, "****"*10)
    for arbitrary_fn in [True]: #, False]:
        results_dict = {
        "mu_0": [],
        "mu_tau": [],
        "floss": [],
        "diffloss": [],
        "true_loss": [],
        }
        np.random.seed(3)
        random.seed(3)
        for mu_0_hat in [1, 1.5, 2, 2.5, 3]: #, 1.5]:
            for mu_tau_hat in [0.2, 0.5, 0.75, 1]: #, 0.25]:
                for ns in [1, 2, 3, 4, 5, 7, 8, 9, 10]:
                    if arbitrary_fn == True:
                        f0_hat = sample_gaussian_process(x_test, width=mu_0_hat) 
                        ftau_hat = sample_gaussian_process(x_test, width=mu_tau_hat)
                        f1_hat = f0_hat + ftau_hat 
                    else:
                        f0_hat = f0_tst + np.random.randn(n) * 0.05
                        f1_hat = f1_tst + np.random.randn(n) * 0.05

                    floss = (n0/n) *  np.mean((f0_star - f0_hat[:n0]) ** 2) + (n1/n) *  np.mean((f1_star - f1_hat[n0:]) ** 2)

                    pred_diff = f0_hat[:n0].reshape(-1, 1) - f1_hat[n0:].reshape(1, -1)
                    gold_diff = f0_star.reshape(-1, 1) - f1_star.reshape(1, -1)
                    diff_loss = (pred_diff - gold_diff) ** 2

                    if method == "ot":
                        diffloss = np.mean(diff_loss * sinkhorn)
                    elif method == "nbrs":
                        diffloss = (n0/n) * np.mean(diff_loss[np.arange(n0), nbrs_0]) + (n1/n) * np.mean(diff_loss[nbrs_1, np.arange(n1)])

                    true_loss = np.mean(((f1_hat - f0_hat) - (f1_tst - f0_tst)) ** 2)
                    results_dict["mu_0"].append(mu_0_hat)
                    results_dict["mu_tau"].append(mu_tau_hat)
                    results_dict["floss"].append(floss)
                    results_dict["diffloss"].append(diffloss)
                    results_dict["true_loss"].append(true_loss)

        import pandas as pd
        df = pd.DataFrame(results_dict)
        # df.to_csv("results.csv")

        std_norm(df, "true_loss")
        std_norm(df, "diffloss")
        std_norm(df, "floss")

        # Now Plot df["floss"] vs df["true_loss"] and df["diffloss"] vs df["true_loss]
        import seaborn as sns
        sns.scatterplot(data=df, x="floss-std", y="true_loss-std", color="blue", s=350, label='(FLoss, ITE Risk)', marker="*")
        sns.scatterplot(data=df, x="diffloss-std", y="true_loss-std", color="red", s=240, label='(PairLoss, ITE Risk)', marker="p")
        # Add legent and labels
        plt.xlabel(r"FLoss/PairLoss $\rightarrow$", fontsize=20)
        plt.ylabel(r"ITE Risk $(\|\tau^* - \hat{\tau}\|) \rightarrow$", fontsize=20)
        plt.legend(fontsize=12)
        plt.tight_layout()
        plt.savefig("motivation/mot_corr.pdf", dpi=300)

        print(f"Floss: {method} arb: {arbitrary_fn}", df["true_loss-std"].corr(df["floss-std"]))
        print(f"Diffloss: {method} arb: {arbitrary_fn}", df["true_loss-std"].corr(df["diffloss-std"]))